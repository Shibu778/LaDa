#include<complex>
#include "poly_cs.h"

namespace VA_CE 
{
  std::vector<Poly_Harmonic> Poly_CS :: harmonics;
  const double Poly_CS :: ZERO_TOLERANCE = 1e-6;

  // constructs polynomial form out pre-existing CS
  //  -- first constructs polynomials for each x dependant part of
  //     each harmonics 
  //  -- second constructs complex polynomial for each k vector, and
  //     obtain resulting norme polynomial
  //  -- third add and multiply all the above
  //  resulting polynomial should be of type double and linear with
  //  respect to each spin
  bool Poly_CS :: operator= (const Ising_CE::Constituent_Strain &_cs )
  {
    if ( harmonics.size() < 1 )
    {
      std::cerr << " Error while creating CS polynomial " << std::endl
                << " Harmonics were not loaded ? " << std::endl;
      return false; // nothing to do, no harmonics
    }
    
    const std::complex<double> imath(0, -2*3.1415926535897932384626433832795028841971693993751058208);
    std::vector < opt::Polynome<> > harm_poly( harmonics.size() );
    { // constructs x-dependant part of harmonics.
      std::vector< opt::Polynome<> > :: iterator i_harm_poly = harm_poly.begin();
      std::vector< opt::Polynome<> > :: iterator i_end = harm_poly.end();
      opt::Polynome<> var_change;
      
      // constructs term  x = 1/N sum S_i
      int pb_size = _cs.size();
      opt::Monome<> monome( 1.0 / double(pb_size) );
      monome.add_term(0);
      var_change.add( monome );
      for ( int i = 1; i < pb_size; ++i )
      {
        *monome.terms_begin() = i;
        var_change.add( monome );
      }

      // then make polynomials via a variable change
      std::vector< Poly_Harmonic > :: const_iterator  i_harm = harmonics.begin();
      for( ; i_harm_poly != i_end; ++i_harm_poly, ++i_harm )
      {
        *i_harm_poly = var_change;
        i_harm->var_change( *i_harm_poly, true ); // linearize = true
      }

    } // end of constructs x-dependant part of harmonics.

    std::vector< opt::Polynome<double> > k_pols( _cs.k_vecs.size() );
    { // constructs k-dependent polynomials

      std::vector< opt::Polynome<double> > :: iterator i_k_pol = k_pols.begin();
      std::vector< rVector3d > :: const_iterator i_r_begin = _cs.r_vecs.begin(); 
      std::vector< rVector3d > :: const_iterator i_r = i_r_begin;
      std::vector< rVector3d > :: const_iterator i_r_end = _cs.r_vecs.end(); 
      std::vector< rVector3d > :: const_iterator i_k = _cs.k_vecs.begin(); 
      std::vector< rVector3d > :: const_iterator i_k_end = _cs.k_vecs.end(); 
      for ( ; i_k != i_k_end; ++i_k, ++i_k_pol )
      { 
        if ( norm2( *i_k ) < ZERO_TOLERANCE ) // don't need to compute Gamma
        {
          ++i_k;
          if ( i_k == i_k_end )
            break;
        }

        // constructs complex k polynomial
        opt::Polynome< std::complex<double> > c_pol, c_pol_conjg;
        i_r = i_r_begin;
        for (int i = 0; i_r != i_r_end; ++i_r, ++i )
        {
          std::complex<double> coef = exp( imath * ( (*i_r)[0] * (*i_k)[0] +
                                                     (*i_r)[1] * (*i_k)[1] +
                                                     (*i_r)[2] * (*i_k)[2] ) );
          opt::Monome< std::complex<double> > monome(coef);
          monome.add_term( i );
          c_pol += monome;
          monome.set_coefficient( conj(coef) );
          c_pol_conjg += monome;
        }

        // now take norm
        c_pol.multiply(c_pol_conjg, true ); // linearize = true

        // converts to real polynomial
        opt::Polynome< std::complex<double> > :: const_Monome_Iterator i_monome = c_pol.monomes_begin();
        opt::Polynome< std::complex<double> > :: const_Monome_Iterator i_monome_end = c_pol.monomes_end();
        for ( ; i_monome != i_monome_end; ++i_monome )
        {
          if ( std::abs( std::imag(i_monome->get_coefficient()) ) > ZERO_TOLERANCE )
          {
            std::cerr << " Error while creating CS polynomial " << std::endl
                      << " Imaginary part not zero: "
                      << i_monome->get_coefficient() << std::endl;
            return false;
          }
          // creates a real Monome from complex monome
          opt::Monome<> monome( std::real( i_monome->get_coefficient() ) );
          opt::Monome< std::complex<double> > :: const_iterator i_term = i_monome->terms_begin();
          opt::Monome< std::complex<double> > :: const_iterator i_term_end = i_monome->terms_end();
          for ( ; i_term != i_term_end; ++i_term )
            monome.add_term( *i_term, true ); // linearize = true -- should be already

          // finally  adds it to k dependant polynomial
          i_k_pol->add( monome );

        } // end of loop over complex monomials

      } // end of loop over k vectors
      
    } // end of constructs k-dependent polynomials

    { // puts everything together into base class opt::Polynome<>
      std::vector< opt::Polynome<double> >:: iterator i_k_pol = k_pols.begin();
      std::vector< opt::Polynome<double> >:: iterator i_k_pol_end = k_pols.end();
      std::vector< rVector3d > :: const_iterator i_k = _cs.k_vecs.begin(); 
      for ( ; i_k_pol != i_k_pol_end; ++i_k_pol, ++i_k )
      {
        if ( norm2( *i_k ) < ZERO_TOLERANCE ) // don't need to compute Gamma
          ++i_k;

        std::vector< Poly_Harmonic > :: const_iterator  i_harm = harmonics.begin();
        std::vector< Poly_Harmonic > :: const_iterator  i_harm_end = harmonics.end();
        std::vector< opt::Polynome<> > :: iterator i_harm_poly = harm_poly.begin();
        opt::Polynome<> polynome;
        polynome.clear();
        for(; i_harm != i_harm_end; ++i_harm, ++i_harm_poly )
        {
          opt::Polynome<> fac_p( *i_harm_poly );
          fac_p *= i_harm->evaluate( *i_k );
          polynome += fac_p;
        }

        std::cout << " i_k_pol ";
        i_k_pol->print_out(std::cout);
        std::cout << " polynome ";
        polynome.print_out(std::cout);
        polynome.multiply( *i_k_pol, true );  // linearize = true;
        add( polynome ); // adds to base class
        
      } // end of loop over k_vector

      operator *=( 1.0 / ( (double)  _cs.k_vecs.size() ) * (double) _cs.r_vecs.size() );

    } // end of puts everything together into base class opt::Polynome<>

    return true;
  }

  bool Poly_CS :: Load_Harmonics( TiXmlElement* const element )
  {
    TiXmlElement *child;
    Poly_Harmonic harmonic;
    double d=1.0;

    if ( !element )
      return false;

    if ( element->Attribute("attenuation", &d) )
      Poly_Harmonic::set_attenuation( d );
    
    child = element->FirstChildElement( "Harmonic" );
    if ( !child )
      return false;
    for ( ; child; child=child->NextSiblingElement( "Harmonic" ) )
    {
      harmonic.clear(); // clear harmonic
      if ( !harmonic.Load(child ) )
        return false;
      harmonics.push_back( harmonic );
    }

    return true;
  }
}
