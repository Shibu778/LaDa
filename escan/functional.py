""" ESCAN functional wrapper. """
__docformat__ = "restructuredtext en"
__all__ = [ 'Functional' ]
from .. import lada_with_mpi
from ..opt.decorators import add_setter
from ._extract import Extract

class Functional(object):
  """ Performs ESCAN calculations, from structure relaxation to wavefunctions. """

  Extract = Extract
  """ Class for output extraction. """

  def __init__(self, inplace=True, workdir=None):
    """ Initializes a ESCAN functional. """
    from numpy import zeros
    from ..vff import Vff
    from ..opt import RelativeDirectory

    super(Functional, self).__init__()
    self.inplace = inplace
    """ If True calculations are performed in the output directory. """
    # checks inplace vs workdir
    if self.inplace: 
      assert workdir == None, ValueError("Cannot use both workdir and inplace attributes.")

    self.vff = Vff() 
    """ The L{Vff} functional with which to relax a structure. """
    self.OUTCAR = "escan_out" 
    """ Escan output file. """
    self.ERRCAR = "escan_err"
    """ Escan error file. """
    self.WAVECAR = "wavefunctions"
    """ Wavefunction file (in g-space). """
    self.eref = None
    """ Reference energy for folded spectrum method.
    
        Set to None for all electron diagonalization.
    """
    self.cutoff = 8.2
    """ Cutoff energy for plane-wave expansion. """
    self.smooth = 1
    """ Smooth potential scaling. """
    self.kinetic_scaling = 1
    """ Smooth kinetic energy scaling. """
    self.nbstates = 1
    """ Number of states to compute. """
    self.itermax = 20
    """ Maximum number of iterations when minimzing wavefuntions. """
    self.nlines = 50
    """ Conjugate gradient line minimization parameter. """
    self.tolerance = 1e-12
    """ Requested minimization accuracy. """
    self.input_wavefunctions = []
    """ Indices of wavefunctions to read in. """
    self.INWAVECAR = "input_escan_wavefunctions"
    """ Filename of input wavefunctions. """
    self.kpoint = zeros((3,1), dtype="float64")
    """ k-point at which to perform calculations.
    
        By default, k-points are given in cartesian coordinates, and units of
        2pi/structure.scale. However, since relaxation will deform the BZ, the
        kpoint given to escan is the one deformed to the relaxed BZ. E.g, the
        meaning of [1,0,0] stays [1,0,0], despite possible relaxation. To turn
        this behavior off, use self.L{_dont_deform_kpoint}.
    """
    self.potential = soH
    """ Type of hamiltonian to use. """
    self.rspace_cutoff = 5
    """ real-space projector cutoff. """
    self.atomic_potentials = None
    """ Parameters to atomic potentials. """
    self.fft_mesh = (18, 18, 18)
    """ Fourrier Transform mesh. """
    self.dnc_mesh = None
    """ Divide and conquer mesh.
     
        Set to None if no divide and conquer is required. 
    """
    self.overlap_mesh = None
    """ Overlap of divide and conquer mesh. 
     
        Set to None if no divide and conquer is required. 
    """
    self.vffrun = None
    """ If None, the structure is relaxed using vff.
          
        Otherwise, it should be an extraction object returned from a previous
        run where vff was computed.
    """
    self.genpotrun = None
    """ If None, the potential is generated.
          
        Otherwise, it should be the extraction object returned by a previous
        run which computed the potential.
    """
    self.do_escan = True
    """ If true, calculations are performed. """

    self._POSCAR = "atomic_input"
    """ Private reference to the atomic input file. """
    self._workdir = RelativeDirectory(path=workdir)
    """ Working directory where calculations are performed. """
    self._POTCAR = "pot.output"
    """ Private reference to the potential file generated by genpot. """
    self._maskr = RelativeDirectory("maskr")
    """ Reference to the maskr projector file. """
    self._INCAR = "escan_input"
    """ Private reference to the escan input file. """
    self._GENCAR = "pot.input"
    """ Private reference to the genpot input file. """
    self._FUNCCAR = "ESCANCAR"
    """ Private reference to the functional pickle. """
    self._dont_deform_kpoint = False
    """ Whether *not* to deform kpoints from input cell to relaxed cell.

        Default is True. Relaxed cell is taken from self.L{_POSCAR}
    """
    self.print_from_all = False
    """ If True, each node will print. """

  @property
  def is_krammer(self):
    """ True if wavefunction is a spinor. """
    from numpy.linalg import norm
    from . import soH
    return True if (norm(self.kpoint) < 1e-12 and self.potential == soH) else False

  @property
  def maskr(self): 
    """ Reference to the maskr projector file. """
    return self._maskr.path
  @maskr.setter
  def maskr(self, value): self._maskr.path = value

  @property
  def workdir(self): 
    """ Reference to the maskr projector file. """
    return self._workdir.path
  @maskr.setter
  def workdir(self, value): self._workdir.path = value
    
  @property
  def lattice(self):
    """ Lattice to use with escan and vff functionals. """
    return self.vff.lattice
  @lattice.setter
  def lattice(self, value): self.vff.lattice = value

  @add_setter
  def add_potential(self, args):
    """ Adds atomic potential to escan.
        
        This property can only be set and never gotten. It serves to add
        potentials to the escan functional.

        >>> escan.add_potential = *args

        Where *args* is a tuple of variable length containing the following:

        - first argument is the path to the atomic potential. 
          The absolute path is deduced when set.
        - second argument is the path to the non-local potential file. 
          If None, then no non-local argument is added. Defaults to None.
        - third trough seventh arguments are the
          non-local potential parameters s, p, d,
          pnl, dnl. Defaults to None (eg 0).
    """ 
    assert len(args) > 2, RuntimeError("Atomic  potentials need at least two parameters.")
    assert len(args) < 9, RuntimeError("Too many parameters when setting atomic potentials.")
    if self.atomic_potentials == None: self.atomic_potentials = []
    self.atomic_potentials.append( AtomicPotential(*args) )

  def __repr__(self):
    from os.path import relpath
    result  = str(self.vff).replace("functional", "vff_functional")
    result += "# Escan definition.\n"
    result += "functional = %s()\n" % (self.__class__.__name__)
    result += "functional.vff                   = vff_functional\n"
    result += "functional.eref                  = %s\n"\
              % ( "None" if self.eref == None else repr(self.eref) )
    result += "functional.cutoff                = %f\n" % (self.cutoff)
    result += "functional.smooth                = %f\n" % (self.smooth)
    result += "functional.kinetic_scaling       = %f\n" % (self.kinetic_scaling)
    result += "functional.nbstates              = %i\n" % (self.nbstates)
    result += "functional.itermax               = %i\n" % (self.itermax)
    result += "functional.nlines                = %i\n" % (self.nlines)
    result += "functional.tolerance             = %e\n" % (self.tolerance)
    result += "functional.rspace_cutoff         = %f\n" % (self.rspace_cutoff)
    result += "functional.fft_mesh              = %i, %i, %i\n" % self.fft_mesh
    result += "functional.genpotrun             = %s\n" % (repr(self.genpotrun))
    result += "functional.do_escan              = %s\n" % (repr(self.do_escan))
    result += "functional.vffrun                = %s\n" % (repr(self.vffrun))
    result += "functional.input_wavefunctions   = %s\n" % (repr(self.input_wavefunctions))
    result += "functional.kpoint                = %s\n" % (repr(self.kpoint))
    result += "functional._dont_deform_kpoint   = %s\n" % (repr(self._dont_deform_kpoint))
    result += "functional.dnc_mesh              = %s\n" % (repr(self.dnc_mesh))
    result += "functional.overlap_mesh          = %s\n" % (repr(self.overlap_mesh))
    if self.potential == localH:
      result += "functional.potential             = localH\n"
    elif self.potential == nonlocalH:
      result += "functional.potential             = localH\n"
    elif self.potential == soH:
      result += "functional.potential             = soH\n"
    else: raise RuntimeError("unknown hamiltonnian %i." % (soH))
    for pot in self.atomic_potentials:
      result += "functional.add_potential         = %s\n" % (repr(pot))
    result += "functional.print_from_all = {0}\n".format(repr(self.print_from_all))
    result += "functional.INWAVECAR = '%s'\n" % (self.INWAVECAR)
    result += "functional.ERRCAR = '%s'\n" % (self.ERRCAR)
    result += "functional.WAVECAR = '%s'\n" % (self.WAVECAR)
    result += "functional.inplace = %s\n" % (repr(self.inplace))
    result += "functional.maskr = '{0}'\n".format(self._maskr.unexpanded)
    result += "functional._INCAR = '%s'\n" % (self._INCAR)
    result += "functional._POTCAR = '%s'\n" % (self._POTCAR)
    result += "functional._GENCAR = '%s'\n" % (self._GENCAR)
    if self.inplace == False: 
      result += "functional.workdir = '%s'\n" % (self._workdir.unexpanded)
    result += "# End of escan definition."

    module = self.__class__.__module__ 
    classname = self.__class__.__name__ 
    header = "from %s import %s, soH, localH, nonlocalH\n" % (module, classname)
    return header + result

  def __call__(self, structure, outdir = None, comm = None, overwrite=False, \
               norun=False, workdir=None, **kwargs):
    """ Performs calculation """
    from copy import deepcopy
    from os import getcwd
    from os.path import exists, isdir, abspath, basename, join, expanduser
    from shutil import rmtree
    from cPickle import dump
    from ..opt import copyfile
    from ..opt.changedir import Changedir
    from ..opt.tempdir import Tempdir

    if lada_with_mpi and comm == None:
      from boost.mpi import world
      comm = world
    is_mpi = False if comm == None else comm.size > 1
    is_root = True if is_mpi else comm.rank == 0

    if outdir == None: outdir = getcwd()

    # make this functor stateless.
    this      = deepcopy(self)
    outdir    = abspath(expanduser(outdir))

    # if other keyword arguments are present, then they are assumed to be
    # attributes of self, with value to use for calculations launch. 
    # If an attribute cannot be found to exist in escan, then vff attributes
    # are checked, and lastly vff.minimizer attributes.
    for key in kwargs.keys():
      if hasattr(this, key): setattr(this, key, kwargs[key])
      elif hasattr(this.vff, key): setattr(this.vff, key, kwargs[key])
      elif hasattr(this.vff.minimizer, key): setattr(this.vff.minimizer, key, kwargs[key])
      else: raise NameError( "%s attribute unknown of escan." % (key) )

    # checks if outdir contains a successful run.
    does_exist = exist(outdir) if is_root else None
    if is_mpi: 
      from boost.mpi import broadcast
      does_exist, overwrite = broadcast(comm, (does_exist, overwrite), 0)
    if does_exist and not overwrite:
      extract = this.Extract(directory=outdir, escan=this, comm=comm)
      if extract.success: return extract # in which case, returns extraction object.
    if is_mpi: comm.barrier() # makes sure directory is not created by other proc!

    # changes to temporary working directory
    if self.inplace: context = Changedir(outdir, comm=comm) 
    else:            context = Tempdir(workdir = this.workdir, comm=comm)
    with context as this._tempdir: 

      # Saves FUNCCAR.
      if is_root:
        path = join(abspath(this._tempdir), this._FUNCCAR)
        with open(path, "w") as file: dump(this, file)
  
      # performs calculation.
      this._run(structure, outdir, comm, overwrite, norun)
  
      # copies output files.
      if not self.inplace:
        with Changedir(outdir, comm = comm) as cwd:
          for file in  [ this._POSCAR + "." + str(world.rank),\
                         this._POTCAR + "." + str(world.rank),\
                         this.FUNCCAR, 
                         this._cout(comm), 
                         this._cerr(comm), 
                         this.vff._cout(comm),
                         this.vff._cerr(comm),
                         this.WAVECAR if comm.rank == 0  else None ]:
            copyfile(file, this._tempdir, 'same exists null', None)
  
    return self.Extract(comm = comm, directory = outdir, escan = this)

  def _cout(self, comm):
    """ Creates output name. """
    if self.OUTCAR == None: return "/dev/null"
    if comm == None:   return self.OUTCAR
    if comm.rank == 0: return self.OUTCAR
    return self.OUTCAR + "." + str(comm.rank) if self.print_from_all else "/dev/null"

  def _cerr(self, comm):
    """ Creates error name. """
    if self.ERRCAR == None: return "/dev/null"
    if comm == None:   return self.ERRCAR
    if comm.rank == 0: return self.ERRCAR
    return self.ERRCAR + "." + str(comm.rank) if self.print_from_all else "/dev/null"


  def _run(self, structure, outdir, comm, overwrite, norun):
    """ Performs escan calculation. """
    import time
    from os.path import join
    from ..opt.changedir import Changedir

    if self.genpotrun != None and self.vffrun != None and self.do_escan == False:
      print "Nothing to do? no relaxation, no genpot, no escan?" 
      return None
    timing = time.time() 
    local_time = time.localtime() 

    # prints some output first
    cout, cerr = self._cout(comm), self._cerr(comm)
    with Changedir(self._tempdir, comm=comm) as cwd:
      with open(cout, "w") as file: 
        print >>file, "# Escan calculation on ", time.strftime("%m/%d/%y", local_time),\
                      " at ", time.strftime("%I:%M:%S %p", local_time)
        if comm != None:
          from boost.mpi import world
          file.write("Computing with {0} processors of {1}.\n".format(comm.size, world.size))
        if len(structure.name) != 0: print "# Structure named ", structure.name 
        # changes directory to get relative paths.
        with Changedir(outdir, comm=comm) as outdir_wd:
          print >>file, repr(self)
        print >>file, "# Performing calculations. "
      
      # makes calls to run
      self._run_vff(structure, outdir, comm, cout, overwrite, norun)
      self._run_genpot(comm, outdir, norun)
      if self.do_escan: self._run_escan(comm, structure, norun)

      # don't print timeing if not running.
      if norun == True: return


      with open(cout, "a") as file: 
        timing = time.time() - timing
        hour = int(float(timing/3600e0))
        minute = int(float((timing - hour*3600)/60e0))
        second = (timing - hour*3600-minute*60)
        file.write("# Computed ESCAN in: %i:%i:%f.\n"  % (hour, minute, second))
      
      if self.do_escan: 
        extract = Extract(comm=comm, directory = outdir, escan = self)
        assert extract.success, RuntimeError("Escan calculations did not complete.")


  def _run_vff(self, structure, outdir, comm, cout, overwrite, norun):
    """ Gets atomic input ready, with or without relaxation. """
    from os.path import join, samefile, exists
    from ..vff import Extract as ExtractVff
    from ..opt import copyfile

    if lada_with_mpi: 
      from boost.mpi import world
      worldrank = str(world.rank)
    else: worldrank = None

    poscar = self._POSCAR 
    if worldrank != None: poscar += '.' + worldrank
    if self.vffrun != None:
      POSCAR = self.vffrun.escan._POSCAR 
      if worldrank != None: POSCAR += '.' + worldrank
      POSCAR = join(self.vffrun.directory, POSCAR)
      rstr = self.vffrun.structure
      if exists(POSCAR): copyfile(POSCAR, poscar, 'same', comm)
      else: self.vffrun.solo().write_escan_input(poscar, rstr)
      VFFCOUT = self.vffrun.escan.vff._cout(comm)
      VFFCOUT = join(self.vffrun.directory, VFFCOUT)
      copyfile(VFFCOUT, self.vff._cout(comm), 'same exists null', comm)
      return

    if norun == True: return
    out = self.vff(structure, outdir=outdir, comm=comm, overwrite=overwrite)
    assert out.success, RuntimeError("VFF relaxation did not succeed.")
    out.write_escan_input(poscar, out.structure)

    # copies vff output to stdout. This way, only one outcar.
    is_mpi = False if comm == None else comm.size > 1
    is_root = True if is_mpi else comm.rank == 0
    if is_root and out.OUTCAR != self.OUTCAR:
      with open(join(out.directory, out.OUTCAR)) as file_in: 
        with open(cout, "aw") as file_out: 
          for line in file_in:
            if line.find("# VFF calculation on ") != -1: print >>file_out, line[:-1]
            if line == "# Performing VFF calculations. ": break
          print >>file_out, line[:-1]
          for line in file_in:
            if line.find("# Computed VFF in:") != -1: break
            print >>file_out, line[:-1]
          print >>file_out, line[:-1]


  def _run_genpot(self, comm, outdir, norun):
    """ Runs genpot only """
    from os.path import basename, exists, join, samefile
    from ..opt import redirect, copyfile

    # using genpot from previous run
    is_mpi = False if comm == None else comm.size > 1
    is_root = True if is_mpi else comm.rank == 0
    if self.genpotrun != None:
      if lada_with_mpi:
        from boost.mpi import world
        POTCAR = self.genpotrun.escan._POTCAR + "." + str(world.rank)
        potcar = self._POTCAR + "." + str(world.rank)
      else:
        POTCAR = self.genpotrun.escan._POTCAR 
        potcar = self._POTCAR
      copyfile(join(self.genpotrun.directory, POTCAR), potcar, 'same exists')
      copyfile(self.maskr, nothrow='same', comm=comm)
      for pot in self.atomic_potentials:
        copyfile(pot.nonlocal, nothrow='none same', comm=comm)
      return

    assert self.atomic_potentials != None, RuntimeError("Atomic potentials are not set.")
    # Creates temporary input file and creates functional
    dnc_mesh = self.dnc_mesh if self.dnc_mesh != None else self.fft_mesh
    overlap_mesh = self.overlap_mesh if self.overlap_mesh != None else (0,0,0)
    if lada_with_mpi:
      from boost.mpi import world
      gencar = '{0}.{1.rank}'.format(self._GENCAR, world) 
    else: gencar = self._GENCAR
    with open(gencar, "w") as file:
      file.write( "%s\n%i %i %i\n%i %i %i\n%i %i %i\n%f\n%i\n"\
                  % ( self._POSCAR, self.fft_mesh[0], self.fft_mesh[1], self.fft_mesh[2], \
                      dnc_mesh[0], dnc_mesh[1], dnc_mesh[2],\
                      overlap_mesh[0], overlap_mesh[1], overlap_mesh[2], self.cutoff,\
                      len(self.atomic_potentials) ))
      for pot in self.atomic_potentials:
        # adds to list of potentials
        file.write(basename(pot.filepath) + "\n") 
        # copy potential files as well.
        copyfile(pot.filepath, nothrow='same', comm=comm)
        copyfile(pot.nonlocal, nothrow='same None', comm=comm)

    copyfile(self.maskr, nothrow='same', comm=comm)

    if is_mpi: # finds larges acceptable number of processors. 
      fftsize = self.fft_mesh[0] * self.fft_mesh[1] * self.fft_mesh[2]
      for m in range(comm.size, 0, -1):
        if fftsize % m == 0: break
      norun = comm.rank >= m
      local_comm = self.comm.split(0 if norun else 1)
    if norun == True: return
    with redirect(fout=self._cout(comm), ferr=self._cerr(comm), append=True) as oestreams: 
      assert is_mpi, RuntimeError('Cannot run genpot with lada_with_mpi == False.')
      from .._escan import _call_genpot
      _call_genpot(local_comm)


  def _write_incar(self, comm, structure, norun=False):
    """ Writes escan input to file. """
    from os.path import basename
    from numpy.linalg import norm
    from quantities import eV
    from ..physics import Ry
    assert self.atomic_potentials != None, RuntimeError("Atomic potentials are not set.")
    # Creates temporary input file and creates functional
    kpoint = (0,0,0,0,0) if norm(self.kpoint) < 1e-12\
             else self._get_kpoint(structure, comm, norun)
    if lada_with_mpi:
      from boost.mpi import world
      incar = self._INCAR + "." + str(world.rank)
    else: incar = self._INCAR
    with open(incar, "w") as file:
      if lada_with_mpi:
        print >> file, "1 %s.%i" % (self._POTCAR, world.rank) 
      else: file.write('1 {0}'.format(self.POTCAR))
      print >> file, "2 %s" % (self.WAVECAR) 
      print >> file, "3 %i # %s"\
                     % ((1, "folded spectrum") if self.eref != None else (2, "all electron"))
      eref = self.eref
      if hasattr(eref, "rescale"): eref = float(eref.rescale(eV))
      cutoff = self.cutoff
      if hasattr(cutoff, "rescale"): cutoff = float(cutoff.rescale(Ry))
      print >> file, "4 %f %f %f %f # Eref, cutoff, smooth, kinetic scaling"\
                     % ( eref if eref != None else 0,\
                         self.cutoff, self.smooth, self.kinetic_scaling )
      if self.potential != soH or norm(self.kpoint) < 1e-6: 
        nbstates = max(1, self.nbstates/2)
        print >> file, "5 %i # number of states" % (nbstates)
      else:
        assert self.nbstates > 0,\
               ValueError("Cannot have less than 1 state (%i)." % (self.nbstates))
        print >> file, "5 %i # number of states" % (self.nbstates)

      print >> file, "6 %i %i %e # itermax, nllines, tolerance"\
                     % (self.itermax, self.nlines, self.tolerance)
      nowfns = self.input_wavefunctions == None
      if not nowfns: nowfns = len(self.input_wavefunctions) == 0
      if nowfns: print >> file, "7 0 # no input wfns\n8 0 # wfns indices"
      else:
        print >> file, "7 %i\n8 %i" % (len(self.input_wavefunctions), self.input_wavefunctions[0])
        for u in self.input_wavefunctions[1:]:
          print >> file, str(u),
        print >> file
      print >> file, "9 %s # input wavefunction filename" % (self.INWAVECAR)

      print >> file, "10 0 1 1 1 0"
      print >> file, "11 %i %f %f %f %f" % kpoint
      
      if   self.potential == localH: print >> file, "12 1 # local hamiltonian" 
      elif self.potential == nonlocalH: print >> file, "12 2 # non-local hamiltonian" 
      elif self.potential == soH: print >> file, "12 3 # spin orbit hamiltonian" 
      else: raise RuntimeError("Unknown potential requested.")
      
      if lada_with_mpi: file.write('13 {0}.{1}'.format(self._POSCAR, world.rank))
      else:             file.write('13 {0}'.format(self._POSCAR))
      print >> file, "14 ", self.rspace_cutoff, "# real-space cutoff" 

      if self.potential != soH:
        print >> file, "15 ", 0, "# Number of spin-orbit potentials"
      else:
        print >> file, "15 ", len(self.atomic_potentials), "# Number of spin-orbit potentials"
        for i, pot in enumerate(self.atomic_potentials):
          filepath = basename(pot.nonlocal)
          print >> file, i + 16, filepath, pot.get_izz(comm),\
                         pot.s , pot.p, pot.d, pot.pnl, pot.dnl

  def _run_escan(self, comm, structure, norun):
    """ Runs escan only """
    from os.path import basename
    from ..opt import redirect


    is_mpi  = False if comm == None else comm.size > 1
    is_root = True if is_mpi else comm.rank == 0
    self._write_incar(comm, structure, norun)
    if is_mpi: # finds larges acceptable number of processors. 
      fftsize = self.fft_mesh[0] * self.fft_mesh[1] * self.fft_mesh[2]
      for m in range(comm.size, 0, -1):
        if fftsize % m == 0: break
      norun = comm.rank >= m
      local_comm = self.comm.split(0 if norun else 1)
    if norun == True: return
    with redirect(fout=self._cout(comm), ferr=self._cerr(comm), append=True) as oestreams: 
      assert is_mpi, RuntimeError('Cannot run escan without mpi communicator.')
      from .._escan import _call_escan
      _call_escan(comm)

  def _get_kpoint(self, structure, comm, norun):
    """ Returns deformed or undeformed kpoint. """
    from numpy import abs, sum, zeros, array
    from ..crystal import deform_kpoint
    from quantities import angstrom
    from ..physics import a0
    if norun == True:
      return 1, self.kpoint[0], self.kpoint[1], self.kpoint[2],\
             structure.scale / float(a0.rescale(angstrom))
    if self._dont_deform_kpoint:
      return 1, self.kpoint[0], self.kpoint[1], self.kpoint[2],\
             structure.scale / float(a0.rescale(angstrom))
    # first get relaxed cell
    relaxed = zeros((3,3), dtype="float64")
    is_mpi  = comm != None
    is_root = comm.rank == 0 if is_mpi else True
    if is_root:
      if is_mpi:
        from boost.mpi import world
        POSCAR = "{0}.{1}".format(self._POSCAR, world.rank)
      else: POSCAR = "{0}.0".format(self._POSCAR)
      with open(POSCAR, "r") as file:
        file.readline() # number of atoms.
        # lattice vector by lattice vector
        for i in range(3): 
          relaxed[:,i] = array([float(u) for u in file.readline().split()[:3]])
      relaxed = relaxed / structure.scale * float(a0.rescale(angstrom))
    if is_mpi:
      from boost.mpi import broadcast
      relaxed = broadcast(comm, relaxed, 0)
    input = structure.cell 
    # no relaxation.
    if sum( abs(input - relaxed) ) < 1e-11:
      return 1, self.kpoint[0], self.kpoint[1], self.kpoint[2],\
             structure.scale / float(a0.rescale(angstrom))
    kpoint = deform_kpoint(self.kpoint, input, relaxed)
    return 1, kpoint[0], kpoint[1], kpoint[2],\
           structure.scale / float(a0.rescale(angstrom))
