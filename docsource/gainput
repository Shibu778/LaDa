//
//  Version: $Id$
//
/** \page xGAinput Inputing Genetic Algorithm Optimizations

  <UL>
     <LI> \ref TagAnd
     <LI> \ref TagBreeding
     <LI> \ref TagxTaboo
     <LI> \ref TagCrossover
     <LI> \ref TagFilenames
     <LI> \ref TagGA
     <LI> \ref TagHistoryTaboo
     <LI> \ref TagHistory 
     <LI> \ref TagKMutation
     <LI> \ref TagKrossover
     <LI> \ref TagLattice
     <LI> \ref TagLayer
     <LI> \ref TagMinimizerVA
     <LI> \ref TagMutation
     <LI> \ref TagObjective
     <LI> \ref TagOffspring
     <LI> \ref TagOperators
     <LI> \ref TagOr
     <LI> \ref TagPrint
     <LI> \ref TagMPI
     <LI> \ref TagRandom
     <LI> \ref TagSave
     <LI> \ref TagScaling
     <LI> \ref TagStatistics
     <LI> \ref TagStore
     <LI> \ref TagTabooOp
     <LI> \ref TagTaboos
  </UL>

    <h1> General Layout </h1>
    A GA input file should something as follows
    \code
<?xml version="1.0" standalone="no" ?>
<Job>
    <MPI pools=7/>
    <GA>
       ...
    </GA>
    <Structure >
       ...
    </Structure>
    <Lattice>
       ...
    </Lattice>
    <Functional type="??">
       ...
    </Functional>
    <Minimizer type="??" />
    <Functional type="??">
       ...
    </Functional>
</Job>
    \endcode
    It will contain a \ref TagStructure tag and a \ref TagLattice tag which
    will act as templates for the decoration minimization.  It will also have one
    or more functional tags (see \ref xFunctionals) describing
    the property to optimize. It may have a minimizer tag for some functional,
    say vff. All of these will depend upon the property to be optimized and on
    the specific optimization which is launched. Finally, it will contain a GA tag
    \ref TagGA within which go all genetic algorithm parameters. These are the
    ones we will go into now.

    <h1> Required GA Tags </h1>
    The following displays the minimum requirement for any GA
    \code
    <GA popsize="50" rate="0.4">
        <Objective type="??" />
        <Breeding>
           ??
        </Breeding>
        <Terminator ref="evaluation" value="10000" />
    </GA>
    \endcode
    They will be described below in turns:
   \secreflist
     \refitem TagGA \<GA\>
     \refitem secstrategy Inputing the search strategy and its objective(s).
     \refitem secbreeding \<Breeding\> and therein
     \refitem secterminator \<Terminator/\> 
     \refitem secstore How to save and output?
     \refitem TagTaboos \<Taboos> ... \</Taboos\>
     \refitem TagStatistics \<Statistics/\>
     \refitem TagPrint \<Print/\>
     \refitem TagFilenames \<Filenames/\>
     \refitem TagHistory \<History/\>
   \endsecreflist

    <h1> Description </h1>
    \section TagGA \<GA\> .. \<GA/\> 
    \addindex \<GA\>
    Contains everything GA. It can take the following attributes:
      \param popsize (Required) Determines the size of the population
      \param rate    (Required) Determines the replacement ration, eg \a rate * \a popsize
                     = number of new children per generation.
      \param tournament (Optional) Size of the deterministic tournament from which parents
                        are selected. (default = 2)
      \param maxgen (Optional) Maximum number of generations before quitting (default =
                    \f$0 (=\infty)\f$ ). The GA may stop first if a condition in a \ref
                    TagTerminator tag is fullfilled prior to \a maxgen generations.
      \param islands (Optional) Number of islands (default = 1).
      \param print (Optional) If this attribute exists, results are printed at each call,
                   whether or not new results have been found (default = false).
      \param seed (Optional - Debugging) Sets the seed of the random number
                  generator. For debugging purposes only!
      \param populate (Optional) How to generate the initial population
             - "paritition": Attempts to cover the whole configuration space. A
               random individual is first generated and added to the starting
               population. Then every  atom of this individual is transmuted
               and the result added to the population. Then only half are transmuted and the
               two possible results added to the population. Finally, only a quarter
               (three-quarters) of the atoms are transmutated and the 4 (4) possible results
               are added to the population.
             - anything else: Populates randomly.
             .
             In any case, the alogrithm makes sure that the individuals in the
             starting population are all different.
     \param x0 (Optional - Optimization Specific) Determines and sets a fixed
               concentration. If it is absent, the concentration is not fixed. Exists in
              - Cluster Expansion groundstates search (\ref ceoptexe)
              - Layered Band-Gap searches (\ref layeredoptexe)
              .

    \section secstrategy Inputing the search strategy and its objective(s)

    Getting a number from the functional is not sufficient to determine what
    optimization you are tryiing to do. Say the functional gives a band-gap. Then
    what? do you want to minimize it? maximize it? shoot for a specific target
    value? Now imagine you have not one, but two functionals, say band-gap and
    in-plane stress. Again, what is you want to do? minimize both? maximize one and
    minimize the other? 

    The \ref TagObjective allow you to specify wether you will minimize,
    maximize, etc... each functional value. The \ref TagScaling will allow the
    you to set the strategy.  <BR>

    Strategy and Objectives are not always easy to identify. Indeed, for
    single-objective GA, \ref TagScaling is not necessary. It is for you to input
    things such that eventually, the GA has a fitness to work with...
    More specifically, the end product of the complete objective+strategy, as
    described below, must be a single number, eg the fitness which the GA will
    optimize. In that respect, the order in which are read \ref
    TagOjbective and \ref TagScaling is important. <BR>

    In \b single-objective GA, let \f$S^(0), \ldots, S^{(i)}\f$ are the
       \e i scalings read from input (and in the order of the input), and \f$O\f$
        is the objective function, \f$x\f$ is the value of the functional (band-gap,
        formation enthalpy,...). Then the GA fitness \f$\mathcal{F}\f$ will be 
       \f[ 
          \mathcal{F} = S^{(i)}\circ S^{(i-1)}\circ\ldots\circ S^{(0)}\circ O(x)
       \f]
    The objective is read from a single \<Objective/\>, and the scalings from
    as many \<Scaling/\> tags.

    In \b multi-objectives GA, things are somewhat more complicated. Indeed,
    the functionals now return a vector \f$x\f$, each component of which refers
    to a particular functional (which to which depends on the executable. See
    their particular description in \ref secexec for details). Then let
     \f$\mathcal{S}^(0), \ldots, \mathcal{S}^{(i)}\f$ be the
       \e i scalings read from input (and in the order of the input), and
       \f$\mathcal{O}\f$ and \f$\mathbf{O} = \{ O_0, \ldots, O_N\} \f$ are the
       objectives, then the GA fitness \f$\mathcal{F}\f$ will be 
       \f[ 
          \mathcal{F} = \mathcal{S}^{(i)}\circ \mathcal{S}^{(i-1)}
                        \circ\ldots\circ \mathcal{S}^{(0)}
                        \circ\mathcal{O}\circ\mathbf{O}(\mathbf{x})
       \f]
    One can see it as an iterative process. 
       - The first action is to evaluate the functional. In multi-objective
         optimizations, the value of each functional is stored as a component \f$x_i\f$
         of a vector \f$\mathbf{x} = \{x_0, \ldots, x_N\} \f$ for future use. In single-objective
         optimizations, the value of the functional is stored as a scalar (eg vector of
         dimension 1).
       - The objectives, as described from input  by \ref TagObjective are then
         applied to these values. More specifically, in multi-objective, we
         have a vector of Objectives \f$\mathbf{O}(\mathbf{x}) = \{O_0(x_0),
         \ldots, O_N(x_N)\}\f$, \e and a "scalar" objective \f$\mathcal{O}[
         \mathbf{O}(\mathbf{x}))]\f$ which reads \f$\mathbf{O}(\mathbf{x})\f$ and
         returns a \e scalar value. In single-objective optimization, since
         there is only one dimension to the vector, one only has \f$O(x)\f$.
       - Scalings are applied, each one in turn, as read from input.
         There are two types of scalings. 
            - scalings \f$ \mathcal{S}^{(u)}\f$ which act
              upon the \e vectorial
              \f$\mathcal{S}^{(u)}[\mathbf{O}(\mathbf{x})]\f$  and return a scalar.
            - scalings \f$ \mathcal{S}[\mathcal{O}\circ\mathbf{O}(\mathbf{x})]\f$ which act
              upon the \e scalar \f$\mathcal{O}[\mathbf{O}(\mathbf{x})]\f$ and
              (also) return a scalar.
            .
       - The GA optimizes the scalar return \f$\mathcal{F}\f$. The vectorial
         components are for intermediate purposes only. It is up to the user to
         make sure that the scalings are inputed in the correct order for the strategy to work.
       .
   \note If there are two scalings which act upon the \e vectorial
         \f$\mathbf{O}(\mathbf{x})\f$, the second one will overwrite the results of the
         first.

   \subsection TagObjective \<Objective/\>  and \<Objectives\> ... \</Objectives\>
   \addindex \<Objective\>
   Objectives can be either \e single or \e multi. A single objective is
   defined for a single functional. A multi-objective will optimize multiple
   functionals. \e Mind your plurals and singulars when inputing Objective. In
general, multi-objectives are made up of single-objectives.  \note Some further
informations are given in the description  of the Objective namespace.
     \param type (Required) can be:
          - (single) "minimize"
            \code
               <Objective type="minimize" />
            \endcode
          - (single) "maximize" 
            \code
               <Objective type="maximize" />
            \endcode
          - (single) "target" in which case a \a target attribute is required.
            \code
               <Objective type="target" target="0.5" />
            \endcode
          - (single) "convexhull" 
            \code
               <Objective type="convexhull" />
            \endcode
          - (multi) "linear" Does a linear sum of the single-objectives. More
            specifically, the input code would look like this.
            \code
               <Objective type="linear" >
                 <Objective type="minimize" coef="1" />
                 <Objective type="target"  target=0.5 coef="1" />
               </Objective>
            \endcode
              The \a coefs attributes are the coefficient to the linear sum
              (default, coef = 1). Which single objective refers to which
              functional in the code above depends on the optimization search you are
              carrying out. See the description of the executables for more information.
              Note that since at this point \<Objective type="linear"\>
              is the only multi-objective which is implemented, 
            - the "type" attribute is not needed ;) eg
              \code
                 <Objective type="linear" >
                   <Objective type="minimize" coef="1" />
                   <Objective type="target"  target=0.5 coef="1" />
                 </Objective>
              \endcode 
            - Whether or not you are doing a linear sum of objectives (or say a
              Pareto optimization), either one or the other of the two codes
              above will work for any and all multi-objective strategies. In other words,
              whether the linear sum is indeed used will depend on the presence/abscense of
              \ref TagScaling tags.
            .
          .
     \param target (with type="target", Required) Determines value to optimize
            for in target optimization.
   
     \param coef (within target="linear" objectives, Optional) Determines the
            weight in the linear sum of objectives (default = 1).

     \param delta (Optional) When no \ref TagStore is present, the objectives
                  automatically define which individuals to save and store for
                  future use. In such cases, \ref TagObjective tags can take on attributes
                   originally assigned to \ref TagStore tags. For more
                  details see description and comments in \ref secstore.
     \warning Do take care to place the "/" in the tags correctly. (see \ref beginners)

   \subsection TagScaling \<Scaling/\>
   \addindex \<Scaling/\>
     In practive, scalings are any objective which require input from the
     complete population to compute. This should become clearer below, but
     think for instance of scaling the fitness of an individual depending on whether
     it has close neighbors or not. The idea, called n iching, would be to make it
     unfavorable for many individuals to be similar, and to promote diversity.
     In such a case, the scaled fitness of an individual will depend upon the rest
     of the population. This is what \ref TagScaling is about.
     \note Scalings are not required \e per \e se.
    
     \param type (Required) Declares the kind of scaling performed
        - "Pareto" (Acts upon the \e vectorial \f$\mathbf{O}\f$) Computes the
          Pareto ranking of an individual with respect to all other individuals
          in the population. See Scaling::Pareto for the definition of Pareto
          ranking. In general, Pareto ranking is used with a niching strategy,
          in which case the input should look like follows.
          \code
               <Objective type="linear" >
                 <Objective type="minimize" coef="1" />
                 <Objective type="target"  target=0.5 coef="1" />
               </Objective>
               <Scaling type="Pareto" />
               <Scaling type="Niching" distance="??" />
          \endcode
          Mark the order of the scalings.
        - "Niching" (acts upon the \e scalar \f$\mathcal{O}\f$) A niching is a
          scaling which attemps to promote diversity by scaling the fitness of
          each individual \f$\sigma\f$ according to how "close" it is
          to all other individuals \f$\sigma_j\f$. In practice, it applies the
          following function:
                 \f[
                     \mathcal{F}(\sigma) = 
                         \frac{\mathcal{F}(\sigma) - \mathcal{O}(\sigma) }
                              {\sum_{\{\sigma_j\}} \mathcal{S}(\sigma, \sigma_j)}
                  \f]
          where \f$\mathcal{S}(\sigma, \sigma_j)\f$ is a sharing function.
          At this point, only the triangular sharing %function is implemented.
          With \f$|\sigma-\sigma_j|\f$ the distance between two individuals,
          it is simply defined as
          \f[ 
              \mathcal{S} = |\sigma_i-\sigma_j| > d_0\ ?\ 0:\ 1 -
                            \left(\frac{|\sigma_i-\sigma_j|}{d_0}\right)^\alpha
          \f]
          As can be seen above, one still needs to define this distance, the
          coefficient \f$\alpha\f$,  and the parameter \f$d_0\f$. For details,
          see below.
        .

     \param distance (with type="Niching" only, Required) 
        There are two "genotypic" distances, which work for all current
        optimizations, and "phenotypic" distances which are only implemented
        for a few optimizations.
        - (all) "GeneralHamming" Implements a generalized Hamming distance
          \f$|\sigma_i-\sigma_j|=\sum_t |q_{t,\sigma_i} - q_{t,\sigma_j}|\f$
        - (all) "Hamming" Implements a Hamming distance for bitstrings
          \f$|\sigma_i-\sigma_j|=\sum_t
          *  (q_{t,\sigma_i} = q_{t,\sigma_j})\ ?\ 1:\ 0\f$
        - (CE groundstates) "Phenotypic" implements a distance which depends
          upon the concentration and \e c the energy \e E of the individuals
          \f$|\sigma_i-\sigma_j|=   \alpha_c |x_{\sigma_i} - x_{\sigma_j}| 
                                 + \alpha_0 |E(\sigma_i) - E(\sigma_j)|  \f$.
          \f$\alpha_c\f$, and \f$\alpha_0\f$ are inputed using the "xcoef" and
          "qcoef0" attributes described below.
        .
     \param alpha (with type="Niching" only, Optional) Integer parameter for the
            triangular sharing function (default alpha = 1). Must positive and
            non-zero. 
     \param d0 (with type="Niching" only, Optional but recommended) Real value
            parameter for the triangular sharing function (defaults to 1.0).
            Must be positive and non-zero.
     \param xcoef (CE Groundstate only) (with type="Niching" and
            distance="phenotypic" only, Optional) Real value
            parameter for the distance function (defaults to 0.0).
            Must be positive or null.
     \param qcoef0 (CE Groundstate only) (with type="Niching" and
            distance="phenotypic" only, Optional) Real value
            parameter for the distance function (defaults to 0.0).
            Must be positive or null.

    \section secbreeding \<Breeding\> and therein
      \subsection TagBreeding \<Breeding\> ... \</Breeding\>
      All breeding operators are contained within these tags. <BR>

      Breeding consists of the set of operations which creates a new individual.
      There are quite a few operations available. For instance, one could have
      \code
        <Breeding>
          <TabooOp>
            <Operators type="or">
              <Krossover prob=0.75/>
              <Mutation rate="0.01" prob=0.25/>
            </Operators >
          </TabooOp>
        </Breeding>
      \endcode
      Hopefully, you are now aware of how complicated things can be...<BR>
      There are two types of breeding operators, those which actually create an
      individual, those which combine other breeding operators together.
      One can nest any number of breeding operators any number of times. Each
      operator will return an individual (the "intermediate" offspring) which
      is used by the next operator.


      We will start off with the innermost tags: eg creating an individual:
      \subsection TagRandom \<Random/\>
      \code
         <Random/>
      \endcode
        \addindex \<Random/\>
        Creates a random individual. God only knows why you would want this.
          \param prob (For the \ref TagOperators within which this tag is found)
                      weight with respect to other breeding operators in \ref TagOperators.
      \subsection TagKrossover \<Krossover/\>
       \addindex \<Krossover/\>
      \code
         <Krossover rate=0.5/>
      \endcode
       Takes two parents (from a deterministic tournament) and creates an
       individual through <A HREF="http://dx.doi.org/10.1088/0953-8984/19/40/402201">
       reciprocal space crossover </A>. It can take the following attributes.
         \param rate (Optional) defines the probability of taking an reciprocal
                value from one parent with respect to the other (default = 0.5). 0.5 will
                generally create an individual which is as much alike to one parent as to the
                other. Values other than 0.5 will create an individual which is more like to
                one parent than the other. Must be between 0 and  1.
         \param prob (For the \ref TagOperators within which this tag is found)
                      weight with respect to other breeding operators in \ref TagOperators.
      \subsection TagKMutation \<KMutation/\>
       \addindex \<KMutation/\>
      \code
         <KMutation rate=0.5/>
      \endcode
       Creates an individual using a single parent for which each reciprocal
       space factor has a certain likelyhood to be mutated. See KMutation for more
       details. 
         \param rate (Optional but recommended) defines the probability of
                mutating each structure factor (default = 0.5 = very bad). Must
                be between 0 and  1.
         \param prob (For the \ref TagOperators within which this tag is found)
                      weight with respect to other breeding operators in \ref TagOperators.
      \subsection TagCrossover \<Crossover/\>
       \addindex \<Crossover/\>
      \code
         <Crossover rate=0.5/>
      \endcode
       Takes two parents (from a deterministic tournament) and creates an
       individual through standard bitstring crossover. It can take the following attributes.
         \param rate (Optional) defines the probability of taking a bit value
                from one parent with respect to the other (default = 0.5). 0.5 will generally
                create an individual which is as much alike to one parent as to the
                other. Values other than 0.5 will create an individual which is more like to
                one parent than the other. Must be between 0 and  1.
         \param prob (For the \ref TagOperators within which this tag is found)
                      weight with respect to other breeding operators in \ref TagOperators.
      \subsection TagMutation \<Mutation/\>
      \addindex \<Mutation/\>
      \code
         <Mutation rate=0.5/>
      \endcode
       Creates an individual using a single parent for which each bit in the
       bitstring has a certain likelyhood to be mutated.  
         \param rate (Optional but recommended) defines the probability of
                mutating each bit (default = 0.5 = very bad). Must
                be between 0 and  1.
         \param prob (For the \ref TagOperators within which this tag is found)
                      weight with respect to other breeding operators in \ref TagOperators.

    \subsection TagMinimizerVA \<Minimizer/\> (for Virtual Atom)
    \addindex \<Minimizer/\>
      \code
         <Minimizer type="VA"/>
      \endcode
      Performs a Virtual Atom minimization upon the current individual. Except for "SA", these
      only works if Virtual Atom has been implemented for the functional you are
      optimizing. Note that it is
      \f$\mathcal{O}\f$ which is minimized. Hence, it looks for the correct objective
      (eg minimization, maximization, target, ...)
         \param type (Required) Specifies the minimization scheme. There are two possibilities
              - "VA", see <A HREF="http://dx.doi.org/10.1088/0953-8984/19/40/402201">
                here </A> and Minimizer::VA.
              - "Beratan", see <A HREF="http://dx.doi.org/10.1021/jp0646168">
                Keinan, Hue, Beratan, and Yang, J. Phys. Chem A \b 111, 146
                (2006)  </A> and Minimizer::Beratan.
              - "SA" Zero temperature simulated annealing. Does not use virtual gradients.
              .
         \param itermax Maximum number of iterations before bailing out
                (default = 0, eg iterates until convergence).
         \param prob (For the \ref TagOperators within which this tag is found)
                      weight with respect to other breeding operators in \ref TagOperators.
      \note Virtual Atom minimizers act in conjunction with the \ref
      TagTaboos tags. In other words, the VA minimizers will not consider exploring
      taboo individuals. 
      \note Other more standard minimizers (for functionals) are described in
            \ref secminimizer. These minimizers are not interchangeable.

          
    Finally, we move on to the operators wich combine other operators together.
    \subsection TagOperators \<Operators\> ... \</Operators\>
    \addindex \<Operators\>
      \code
        <Operators type="??">
          <Krossover prob=0.75/>
          <Mutation rate="0.01" prob=0.25/>
          ...
        </Operators >
      \endcode
    These operators do exactly that... Within 'em are nested operators which
    are either applied one after the other with a certain a probability, or of
    which only one is applied, depending upon similar probabilities. Each
    nested breeding operator should have a "prob" attribute (which, if not there,
    defaults to 1.0).
       \param type (Optional) There are two types defining the combination (default = "and").
              - "and" The operators within are applied successively with the
                probability defined within each instance by the attribute
                "prob".
              - "or" Only one of the operators whithin is applied. This
                operator is chosen using a russian roulette and the probilities
                defined within each instance by the attribute "prob".
              .
         \param prob (For the \ref TagOperators within which this tag is found)
                      weight with respect to other breeding operators in \ref
                      TagOperators. Yes, you can nest these operators.
    \note By default, \ref TagBreeding is an \<Operator type = \"and"\> operator.

    \subsection TagAnd \<And\>...\</And\>
    \addindex \<And/\>
    Short for \<Operators type="and" \> ... \<Operators/\>.
    \subsection TagOr \<Or\>...\</Or\>
    \addindex \<Or/\>
    Short for \<Operators type="or" \> ... \<Operators/\>.
     
    \subsection TagTabooOp \<TabooOp\> ... \</TabooOp\>
    \addindex \<TabooOp\>
      \code
       <TabooOp>
         ... 
       </TabooOp>
      \endcode
      The operators nested within this tag are applied until a non-taboo
      individual is created. Which individuals are taboo is defined by the tags
      within \ref TagTaboos.
         \param prob (For the \ref TagOperators within which this tag is found)
                      weight with respect to other breeding operators in \ref
                      TagOperators. 
         \note It is best to put \ref TagMinimizerVA \e outside the \ref
               TagTabooOp tags since the latter already work in conjunction
               with the \ref TagTaboos tags.

     \section TagTerminator \</Terminator/\>
       \addindex  \<Terminator/\>
       \code
        <Terminator type="evaluation" value=1000 />
       \endcode
       This tag define a condition upon which termination is performed. 
       It is not truly required, but strongly recommended. 
          \param type (Required) There is only one possible termination at this point.
                 - "evaluation" terminates when the functional has been called
                   "value" times.
                 .
          \param value (Required) the value for which termination happens.

     \section secstore How to save and output?
        There are different aspects to this question:
           - Which of the "good" results should be stored?
           - How to save stuff in order to resume the run later on?
           .
        The first is answered via \ref TagStore (or \ref TagObjective, but see
        \ref TagStore for explanation). The second question is answered by \ref
        TagSave and \ref TagRestart.
        
        \subsection TagStore \<Store\> ... \</Store\>
          It did not seem obvious that the individuals which are the best
          optimized for a problem are those with the best fitness... Indeed, say
           a Pareto ranking is performed, you may want not the Pareto optimals,
          but rather, those Pareto optimales which have a bandgap within.... whatever. 
          In any case, it is possible to include a tag which will store
          individuals depending on how a newly defined objective (as described in \ref TagObjective).
          \code
             <Store>
               <Objective>
                  .... 
               </Objective>
             </Store>
          \endcode
          Whether you do this is up to you.
          \note If there are no \ref TagStore in input, then by default storage
                happens depending on the objectives of the GA. In that case,
                \<Objective\> can take the attributes of \<Store\>.
          \note The results are stored as XML in the file defined in \ref TagFilenames.
          \param delta Individuals with a fitness within delta  of the (current) best
                       individual are stored.
    
        \subsection TagSave \<Save/\>
          Defines what to restart from. Results as defined by \ref TagStore are always saved.
          \note The file to which the following is saved can be specified in
                \ref TagFilenames.
            \param every (Optional) How often to save to file, in number of generations.
                         Must be positive. default = 0, eg every generation.
            \param what Can take the following values.
                        - "population" saves the population ( in condensed format to save space). 
                        - "history" saves the history ( in condensed format to
                          save space). Useless unless you have \ref TagHistory.
                        - "all"  both of the above (and results).
                        .

        \subsection TagRestart \<Restart/\>
          Defines what to reload.
          \note The file to which the following is loaded from can be specified in
                \ref TagFilenames.
            \param what Can take the following values.
                        - "results" load previously saved results.
                        - "population" loads previously saved population.
                        - "history" load previously saved history. Useless
                          unless you have \ref TagHistory.
                        - "all"  all of the above.
                        .
                        
        \section TagTaboos \<Taboos\> ... \</Taboos\>
           \code 
             <Taboos>
               <Offspring/>
               <Population/>
               <History/>
               <Concentration/>
                ...
             </Taboos>
           \endcode
           Contains all tags defining the individuals which \e \b cannot be
           created when applying \ref TagTabooOp and \ref TagMinimizerVA. 
           There are three "general" tags which work for all executables, and
           some tags which only work in some implementations.
           
           \subsection TagOffspring \<Offspring/\>
             \addindex \<Offspring/\>
             Prohibits creating individuals which are already within the
             offspring population. Use this tag in conjunction with \ref TagPopulation to
             make sure that from one generation to the next, all individuals within the
             population are unique.
           \subsection TagPopulation \<Population/\>
             \addindex \<Population/\>
             Prohibits creating individuals which are already within the
             current population. Use this tag in conjunction with \ref TagOffspring to
             make sure that from one generation to the next, all individuals within the
             population are unique.
           \subsection TagHistoryTaboo \<History/\> (within \<Taboos\> ... \</Taboos\>)
             \addindex \<History/\> 
             Prohibits creating individuals which have already been evaluated at
             some point. Useless unless \ref TagHistory is defined.
           \subsection TagxTaboo \<Concentration\>
             \addindex \<Concentration/\>
             Makes taboo all individuals with a concentration (first site concentration
             in ternaries and quaternaries) outside the specified range.
               \param lessthan (Optional) Real value between 0 and 1 below
                               which individuals are not allowed (strictly below).
               \param morethan (Optional) Real value between 0 and 1 above
                               which individuals are not allowed (strictly above).
           \subsection TagLayer \<Layer\>
             \addindex \<Layer/\>
             For "layered" optimization (eg molecularity) only. Makes taboo
             individuals which have a thickness of atom 1/site 1 (atom 2/site 1)
             larger than d0 (d1). The atom and site index depends on the way
             you have inputed things in \ref TagLattice.
               \param d0 (Required)  Maximum number of layers of atom 1 before
                         the structure blows up.
               \param d1 (Required)  Maximum number of layers of atom 2 before
                         the structure blows up.
          
         \section TagStatistics \<Statistics/\>
           \addindex \<Statistics/\>
           Prints out "statistical" information. There can be as many of
           these as you want.
               \param type Defines what statistics to print out.
                     - "census" Population size - number of twins, triplets, ...
                     - "AverageFitness" over the population. Fitness is the
                       \f$\mathcal{F}\f$ in \ref secstrategy.
                     - "AverageQuantity" over the population. Fitness is the
                       \f$\mathbf{O}\f$ in \ref secstrategy.
                     .

         \section TagPrint \<Print/\>
           \addindex \<Print/\>
           Prints out individuals at the end of each generations to the output
           file (not xmgrace file). Which individuals is defined by the
           following attributes
               \param type Defines which individuals to print
                     - "pop" print out the full population.
                     - "offspring" print out the offspring only.
                       \f$\mathcal{F}\f$ in \ref secstrategy.
                     - "animation" prints out an animation of the best
                       individual at each generation in an xyz format.
                       The filename can be set using the correct \ref TagFilenames.
                     .
          
         \section TagFilenames \<Filenames/\> (within \<GA\> ... \</GA\>)
           Defines different files from which to read input, and to which to
           save output. You can have as many tags as you want. All will be read.
              \param stop      (Optional) GA stops if this file exists
              \param evaluator (Optional) Place to read functional info from.
                               default = same as GA input.
              \param restart   (Optional) Place to restart info from.
                               default = same as GA input.
              \param save      (Optional) Place to save restart/result info to.
                               default = same as GA input.
              \param out       (Optional) Place to save standard output.
                               default = "out" in working directory
              \param xmgrace   (Optional) Place to save xmgrace output.
                               default = "xmg" in working directory
              \param BandEdge  (Optional, pescan only) Place to save and read band-edges.
                               default = "BandEdges" in working directory
                               For file format, see
                               \link BandGap::Darwin::references_filename here\endlink.
                               For (quirky) behavior, see
                               \link BandGap::Darwin::Continue() here\endlink.
              \param animation (Optional) PLace to save an xyz animation of the
                               best result. This tag has no effect unless the
                               correct \ref TagPrint is present.

         \section TagHistory \<History/\>
             Whether to keep track of all evaluated individuals. Generally,
             this is only usefull in conjunction with \ref TagTaboos and \ref
             TagHistoryTaboo.

         \section TagMPI \<MPI/\>
           Sets up the mpi scheme. Depending on the value of the attribute \a
           pools, there are two possible schemes at present.
             \param pools = 1 (default) Only one pool of processors. All
                                        processors run the same way.  Band-gaps
                                        are evaluated using the number of
                                        processor the GA job was sent with (eg mpirun -n something).
             \param pools = n The processors are separated into n pools + 1
                              lone processor. The lone processor tells the n
                              pools what to do. Indivduals are sent to the
                              pools for evaluation. Hence, it is not necessary
                              to use more pools than you have new offspring at
                              each generation. mpirun should be launched on n*m
                              +1 processors, where n is the number of pools, m
                              the number of processors per pool. If you do
                              launch with an even number of processors, (at
                              least) one processor will be idle. When computing
                              band-gaps and such, there are restrictions as to
                              how many processors each computation can use (see
                              nanopse for more details).
             \note \a pools does not denote the number of processors, but the
                            number of groups into which the processors are ...
                            pooled.
*/

