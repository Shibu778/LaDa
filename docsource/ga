/** \ingroup Genetic
  \page Genetic Genetic Algorithm

 The following is an attempt at explaining how the code is structured. Indeed,
even when starting from something as elaborate as EO, quite some coding is
required to obtain a %GA library capable of handling diverse physical problems. 
The following has been separated into two poetically named sections
  - \ref secbas
     - \ref secpop
     - \ref seceval
     - \ref secbreed
     - \ref seccull
     .
  - \ref seccomp
     - \ref sectraits
     - \ref secci
     - \ref rawf
     .
  - \ref secnew
     - \ref secobject
     - \ref secvaluator
     .
  .
  \section secbas Basic Components
  Genetic Algorithms mimic biological evolution (in the case of Darwinian %GA)
and not quite so natural evolution (in the case of Lamarckian %GA) by favoring
those traits within a population which are beneficial to
the objectives of the optimization. More specifically, the population could be
composed of fcc decorations of a given cell-shape, and the goal of the search
could be the minimum-energy (or groundstates) decorations of that cell-shape.
The favored traits then become the patterns present in the true ground-states
of that cell-shape (say first neighbor clustering, or first-neighbor ordering).

Generally, a genetic algorithm follows the following simple flowchart
\dot
  digraph example {
        node [shape=record, fontname=Helvetica, fontsize=10];
        b [ label="Population" URL="\ref B"];
        c [ label="Evaluation/Fitness/Ranking" URL="\ref C"];
        d [ label="Offspring Generation" URL="\ref D"];
        e [ label="Replacement/Culling" URL="\ref E"];
        b -> c [ arrowhead="open" ];
        c -> d [ arrowhead="open" ];
        d -> e [ arrowhead="open" ];
        e:e -> b:e [ arrowhead="open" ];
    }
\enddot
  - <span style="color: blue"> \anchor B Population</span>: A collection of individuals
  - <span style="color: blue"> \anchor C Evaluation/Fitness/Ranking</span>: All and any operation which
           which gives the algorithms the ability to discriminate between
           individuals, e. g. <STRONG>A</STRONG> is better than <STRONG>B</STRONG>, not as
           good as <STRONG>C</STRONG>. It is expected that an weak ordering
           operator acting on the population can be defined from this step.
  - <span style="color: blue"> \anchor D Offspring Generation</span>: All and any operation which:
         <UL>
            <LI> Selects (a) parent(s) from the current population 
            <LI> Mates these (this) parent(s) such that an offspring is created
         </UL>
  - <span style="color: blue"> \anchor E Replacement/Culling</span>: Any and all operations which are used
       to combine a new populations from both offspring and current population.
       This involves at most four operations:
          - Remove some (between 0 and all) individuals from the offspring population.
          - Remove some (between 0 and all) individuals from the parent population.
          - Combine remaining offspring and parent population into current population
          - Remove some (between 0 and not all) individuals from the current population.
          .
  .
 
  The difficulty of implementing a %GA code lies in separating the generic
aspects described in the flowchart above, from the specific application to one
single problem, such as Cluster Expansion ground-state search. To put it in
coder linguo, it is necessary to distinguish between the method, %GA itself,
and the objects on which the method is applied, eg some fcc cell-shape. Such a
separation can be easily implemented in C++ <em>via</em> generic programming.
In the following are outlined the different parts of the %GA implementation.

\note The class GA::Darwin combines the whole genetic algorithm into one
object. It reads and writes and runs and bakes and makes all the calls.

 \subsection secpop Population 
 The population is a vector of individuals. More specifically, it is created
using the eoPop template object of EO. Technically, the population object can
be changed across the full %GA implementation through Traits::GA::t_Population. 
 
 \subsection seceval Evaluating/Fitness/Rank
 The evaluation of an individual is generally done through a two layer scheme
which keeps %GA generics separate from application-specifics. The %GA itself
calls an object in namespace Evaluation. This evaluation object in turn calls
an object derived from GA::Evaluator (say CE::Evaluator) which contains an
application-specific functional. In practice this derived class of
CE::Evaluator, as well as some Object class are that need be created to
introduce either a new optimization object or a new functional. How to go from
the functional evaluation to an actual number which GA can understand and
optimize is explained \ref rawf in the section below.

 \subsection secbreed Offspring Generation
  This is one the most application-specific part of the genetic algorithm.
Nonetheless, there are still a few layers of abstraction. The creation of new
offspring is handled by a GA::Breeder object. This object creates a
eoSelectivePopulator, eg something which upon request will select an individual
from the current population and store it as an offpsring. Once a individual has
been selected ( and possibly another two or three) GA::Breeder calls a genetic
operator which will act upon this individual to transform it, say via
crossover. The type of selection operator is defined in
GA::Darwin::make_breeder. A number of generic genetic operators are read from
XML input in GA::Darwin::make_genetic_op. 


\subsection seccull Culling and Replacement
The culling and replacement aspects are entirely handled by EO.
See GA::Darwin::make_breeder and GA::Darwin::run for more details. This type of
operation only needs to rank individuals and act upon collection of
individuals. As such it can be made highly generic. It is recommened to look to
EO for behaviors beyond the steady-state implemented here.

\section seccomp More complicated concepts
 In the previous section, we have looked at rather basic concepts of Genetic
Algorithms. Here we introduce other programming concepts which allow for
greater abstraction between the %GA itself and the object (and functional) to
which it is applied.

\subsection sectraits Traits for GA
  A namespace Traits is declared which allows to keep all application-specific
types in one place. More specifically, three types of traits are used in %GA:
      - Traits::Quantity class, capable of discerning between scalar and
        vectorial quantities. Used for single vs multi-objective stuff
      - Traits::Indiv class, defines all traits needed to create an individual,
        eg the quantity type and the fitness type.
      - Traits::GA class, defines all types needed by GA, eg the individual,
        the population, the evaluator...
Technically, it is possible to change behaviors across the whole %GA
implementation by simply using different %Traits. This, of course, may have
unwanted consequences.


 \subsection secci Creating Generic Individuals 
 Before any type of %GA can be done, one needs to define the individuals on
which the algorithm is applied. Quite obviously, these individuals contain
application specific information, as well as generic %GA content. To this end,
a class of individuals (Individual::Base) has been declared containing a
template variable Individual::Base::t_Object. 
A simple implementation would be:
\code
    template<class T_OBJECT>
    class Individual : public eoObject, public eoPersistent
    {
      public:
        typedef T_OBJECT t_Object; 
      protected:
        t_Object Object; // an instance of the application-specific object

     // more stuff
    };
  }
\endcode
Turns out that things are slightly more complicated...  In order to keep things
well separated, anything related to individuals has been put into a separate
namespace. What is more a class of "traits" is used as the templated object,
since it allows us to introduce a number of generic types, in addition to
t_Object. Eventually, the current implementation should look something like
this.
\code
  namespace Individual
  {
    template<class T_INDIVTRAITS>
    class Base : public eoObject, public eoPersistent
    {
      public:
        typedef T_INDIVTRAITS t_IndivTraits; 
      protected:
        // Application specific type 
        typedef typename t_IndivTraits :: t_Object t_Object;
      protected:
        t_Object Object; // Instance of an application specific object
    };
  }
\endcode
The end result is the same however, Individual::Base wraps around this object a
number of behaviors and quantities which are generic to %GA,
while it leaves all (or most) application specifics to
Individual::Base::t_Object. An instance of an application-specific object is
not sufficient however. Indeed, one expects a value to be attached to each
object, eg the band-gap or the formation enthalpy to a structure. As such, the
implementation of Individual::Base contains a second type called
Individual::Base::t_Quantity.
\code
  namespace Individual
  {
    template<class T_INDIVTRAITS>
    class Base : public eoObject, public eoPersistent
    {
      public:
        typedef T_INDIVTRAITS t_IndivTraits; 
      protected:
        // Application specific type 
        typedef typename t_IndivTraits :: t_Object t_Object;
        typedef typename t_IndivTraits :: t_QuantityTraits t_QuantityTraits;
        // Type defining Band-gap, or formation enthalpy, or etc... Eg raw fitness
        typedef typename t_QuantityTraits :: t_Quantity           t_Quantity;  
      protected:
        t_Object Object; // Instance of an application specific object
        t_Quantity quantity;  // Instance of an application specific quantity (or raw fitness)
    };
  }
\endcode
Note that Individual::Base::t_Quantity is defined <em>via</em> a second traits
class Individual::Base::t_QuantityTraits. The reason for this is simply that it
makes the integration of multi-objective %GA easier. At this point, think of
t_Quantity as a simple scalar float type. 

Finally, we must be able to rank the individuals. As such one last type is
introduced, Individual::Base::t_Fitness, as well as ordering operators.
\code
  namespace Individual
  {
    template<class T_INDIVTRAITS>
    class Base : public eoObject, public eoPersistent
    {
      public:
        typedef T_INDIVTRAITS t_IndivTraits; 
      protected:
        // Application specific type 
        typedef typename t_IndivTraits :: t_Object t_Object;
        typedef typename t_IndivTraits :: t_QuantityTraits t_QuantityTraits;
        // Type defining Band-gap, or formation enthalpy, or etc... Eg raw fitness
        typedef typename t_QuantityTraits :: t_Quantity           t_Quantity;  
        typedef typename t_IndivTraits::t_Fitness t_Fitness; //!< Fitness type
      protected:
        t_Object Object; // Instance of an application specific object
        t_Quantity quantity;  // Instance of an application specific quantity (or raw fitness)
        t_Fitness repFitness // Allows ordering of individuals

      private:
        typedef Base<t_IndivTraits> t_This; //!< This class type

      public:
        bool operator<(const t_This& _eo2) const { return repFitness < _eo2.repFitness; }
        bool operator>(const t_This& _eo2) const { return repFitness > _eo2.repFitness; }
    };
  }
\endcode
The class defined above contains most everything needed for a generic %GA
individual. The most puzzling at this point, is probably this separation
between the "raw fitness" Individual::Base::quantity and the "polished" fitness
itself Individual::Base::repFitness. To this we now turn.

\subsection rawf Raw Fitness, Polished Fitness, and Objectives

With any %GA scheme, there are a few things we can count on: something is gonna
get evaluated, and depending on what we want, it means the individual is good
or bad. Obvious and simple as long as you don't go into the details. But what
is it "we want"? Do we Minimize, Maximize, look for a target value, etc...?
The distinction between an individual's raw fitness Individual::Base::quantity,
the "polished" fitness Individual::Base::repFitness, and the Objective functors
which link the two, provides us with the necessary abstraction to use the same
code for all types of objectives, whether we are minimizing, maximizing,
constructing a convexhull...

First off, let us look at the fitness. Once again, it is defined in a namespace
(called, appropriately) Fitness, with a classic base class Fitness::Base. The
present implementation allows for both single and multi-objective fitnesses.
Only the latter will be discussed here. Only a few behaviors are necessary:
namely, we want to store a number and be able to compare it.
\code
namespace Fitness
{
  template<class T_QUANTITYTRAITS >
  class Base<T_QUANTITYTRAITS>
  {
    typedef Base<T_QUANTITYTRAITS> t_This;
    public:
      typedef T_QUANTITYTRAITS t_QuantityTraits;
      typedef typename t_QuantityTraits :: t_Quantity t_Quantity;

    protected:
      t_Quantity quantity;

    public:
      bool operator<(const Base & _f) const
        { return quantity < _f.quantity; }
      bool operator>(const Base & _f) const
        { return quantity > _f.quantity; }
      bool operator==(const Base & _f) const
        { return quantity == _f.quantity; }

  };
\endcode
  If you look into the actual implementation, you will find that it is a bit
more complicated, since it allows for whatever type t_Quantity may be (eg, does
fuzzy math for reals, exact math for integerers...).  The point is anyhow to
implement weak ordering operators to judge the relative worth of two individuals. 

All is needed now is something to link Individual::Base::t_Quantity (which
contains the formation enthalpy, total energy, or whatever else the functional
of interest yields) to Fitness::Base. For this, a number of functors are
created which allow to Objective::Maximize, Objective::Minimize,
Objective::convexHull, etc... Let us look at Objective::Maximize,
\code
namespace Objective
{
  template< class T_GA_TRAITS >
  class Maximize : public Types< T_GA_TRAITS > :: Scalar
  {
    public:
      typedef T_GA_TRAITS t_GATraits;
    protected:
      typedef typename t_Base :: t_Fitness                t_Fitness;
      typedef typename t_Base :: t_Quantity               t_Quantity;


    public:
      Maximize() {}
      Maximize( const Maximize &) {}
      virtual ~Maximize() {}
      
      virtual t_Fitness operator()(t_Quantity _val)
       { return t_Fitness( -_val ); }
  };
}
\endcode
Quite simply, this functor takes in a t_Quantity object, and returns a fitness
of opposite value. Why opposite? because the default in this code is to
minimize. The negation allows us to turn a minimization in a maximization.
Again, the actual implementations of the Objective functors is made quite a bit
more objective by single vs multi-objective stuff, and by Lamarkian related
stuff (eg we need to be able to evaluate gradients).
\note
There is one last component to obtaining the fitness, which is called ranking.
I won't go into the details, but it allows us to act upon the "polished"
fitnesses one last time, and change them for, say, niching purposes.


\section secnew Introducing a new functional and/or new object 
The %GA code interacts with application-specific code <em>via</em> two objects:
  - an Object class
  - a class derived of GA::Evaluator
  .
The first class should contain the minimum information necessary for coding the
characteristics of an individual. Say, for an fcc, single-cell-shape,
combinatorial search, this would be simply the bitstring coding for the
occupation of each lattice-site. Each individual will contain an instance of
this class. So small footprints is best. For more details see \ref secobject

The second object is used mainly by GA::Darwin. It should contain all
functional related evaluation subroutines, as well as the ability to mate
individuals. For more details see \ref secvaluator


\subsection secobject Creating a new Object
 The Object class is meant to contain the minimum number of variables which
completely defines an individual. Indeed, each individual will contain  an
instance of this class. The following skeleton declaration contains all
necessary members (see darwin/bitstring.h).
\code
  struct Object
  {
    public:
      typedef std::vector< types::t_real > t_Container;
      typedef t_Container :: value_type t_Type;
      typedef t_Container :: iterator iterator;
      typedef t_Container :: const_iterator const_iterator;

    public:
      t_Container bitstring;

    public:
      Object() {}
      Object(const Object &_c) : bitstring(_c.bitstring) {};
      Object(const t_Container &_c) : bitstring(_c) {};
      ~Object() {};
    
      bool operator==( const Object &_c ) const;

      void mask( types::t_unsigned _start, types::t_unsigned _end);
      t_Container& Container() { return bitstring; }
      const t_Container& Container() const { return bitstring; }

      const_iterator begin() const
        { return bitstring.begin();  }
      const_iterator end() const
        { return bitstring.end();  }
      iterator begin() 
        { return bitstring.begin();  }
      iterator end()
        { return bitstring.end();  }
      types::t_real get_concentration() const;

#ifdef _MPI
       bool broadcast ( mpi::BroadCast &_bc );
#endif
  };
  std::ostream& operator<<(std::ostream &_stream, const Object &_o);
  void operator<<(std::string &_str, const Object &_o);
  void operator<<(Object &_o, const std::string &_str );
\endcode

 t_Container should define a container with all necessary variables. Its
iterator and const_iterator are also redefined, such that the full content of
Object can be accessed through begin() and end() member functions. Objects
should copiable through a copy constructor, and comparable through the explicit
declaration of operator==(). The member %function broadcast should allow
serialization of object. See \ref MPI. 

An external operator<< should allow for the object to be dumped to a stream.
Furthermore, it is expected that an object can write itself to and read itself
from an std::string via overloaded operator<<.


The following are very bitstring related and may become deprecated at some
point.  A member %function Container() should allow direct access to the
container.  mask() should allow the logical negation of part of the encoding.
get_concentration() should return the concentration of the object.

\todo Remove mask, get_concentration, and partition_populate form Object and
GA::Darwin. This is way too bitstring like.

\see BitString::Object, SingleSite::Object, TwoSites::Object, CE::Object,
BandGap::Object, Molecularity::Object

\subsection secvaluator Creating a new Evaluator
 The evaluator is expected to contain most everything application-specific.
Indeed, GA::Darwin and related will call upon it to,
  - contain the traits of the desired individual (see Traits::Indiv)
  - load and save objects to xml
  - evaluate an object
  - evaluate gradients
  - create functors capable of mating operations
  - create functors for taboo
  - ...
  .
All these and more are described in GA::Evaluator. The simplest way to create a
new evaluator is to derive it from GA::Evaluator. Note that no virtual %function
is declared. Indeed, it is expected the %GA run itself will be created using a
GA::Darwin object specifically instanciated with your evaluator.
\see BitString::Evaluator, SingleSite::Evaluator, TwoSites::Evaluator, CE::Evaluator,
BandGap::Evaluator, Molecularity::Evaluator

\note Since we are mostly interested in structures with a set cell-shape and
lattice-type, a number of operators have been created to deal with them. See
among others the SingleSite and TwoSite stuff, as well as gaoperators.h

\note In order to separate the genomic representation from what is done to
evaluate it (eg from the functional), one can go one step farther and introduce
Keeper objects (see for instance Pescan::Keeper), as well as functional types
(see Pescan::Darwin for instance).

*/
  
